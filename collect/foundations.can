Unit = r:* → a:r → r
id = r:* ⇒ a:r ⇒ r ~
	a

const = t:* ⇒ s:* ⇒ a:t ⇒ b:s ⇒ t ~
	a
drop = t:* ⇒ s:* ⇒ a:t ⇒ b:s ⇒ s ~
	b
flip = t:* ⇒ s:* ⇒ r:* ⇒ f:(t→s→r) ⇒ b:s ⇒ a:t ⇒ r ~
	f a b
$ = t:* ⇒ r:* ⇒ f:(t→r) ⇒ a:t ⇒ r ~
	f a
. = t:* ⇒ s:* ⇒ r:* ⇒ f:(s→r) ⇒ g:(t→s) ⇒ a:t ⇒ r ~
	f (g a)

Boolean = r:* → true:r → false:r → r
True = r:* ⇒ true:r ⇒ false:r ⇒ r ~
	true
False = r:* ⇒ true:r ⇒ false:r ⇒ r ~
	false

not = x:Boolean ⇒ Boolean ~
	x Boolean False True
and = x:Boolean ⇒ y:Boolean ⇒ Boolean ~
	x Boolean y False
or = x:Boolean ⇒ y:Boolean ⇒ Boolean ~
	x Boolean True y
xor = x:Boolean ⇒ y:Boolean ⇒ Boolean ~
	x Boolean (not y) y

Eq = t:* ⇒ x:t → y:t → Unit → Boolean

eqBoolean = Eq Boolean ~
	x:Boolean ⇒ y:Boolean ⇒ Unit ⇒ Boolean ~
	x Boolean y (not y)

Ordering = r:* → lt:r → eq:r → gt:r → r
LT = r:* ⇒ lt:r ⇒ eq:r ⇒ gt:r ⇒ r ~
	lt
EQ = r:* ⇒ lt:r ⇒ eq:r ⇒ gt:r ⇒ r ~
	eq
GT = r:* ⇒ lt:r ⇒ eq:r ⇒ gt:r ⇒ r ~
	gt

chainOrder = x:Ordering ⇒ y:Ordering ⇒ Ordering ~
	x Ordering LT y GT

eqOrdering = Eq Ordering ~
	x:Ordering ⇒ y:Ordering ⇒ Unit ⇒ Boolean ~
	x Boolean (y Boolean True False False) (y Boolean False True False) (y Boolean False False True)

Ord = t:* ⇒ x:t → y:t → Unit → Ordering

ordBoolean = Ord Boolean ~
	x:Boolean ⇒ y:Boolean ⇒ Unit ⇒ Ordering ~
	x Ordering (y Ordering EQ GT) (y Ordering LT EQ)

ordOrdering = Ord Ordering ~
	x:Ordering ⇒ y:Ordering ⇒ Unit ⇒ Ordering ~
	x Ordering (y Ordering EQ GT GT) y (y Ordering LT LT EQ)

eqOrd = t:* ⇒ ordT:Ord t ⇒ Eq t ~
	x:t ⇒ y:t ⇒ Unit ⇒ Boolean ~
	(ordT x y id) Boolean False True False

Map = u:(*→*) ⇒ t:* → s:* → f:(t→s) → a:u t → Unit → u s
Replace = u:(*→*) ⇒ t:* → s:* → b:s → a:u t → Unit → u s
Filter = u:(*→*) ⇒ t:* → pred:(x:t→Boolean) → a:u t → Unit → u t

mapReplace = u:(*→*) ⇒ mapU:(Map u) ⇒ Replace u ~
	t:* ⇒ s:* ⇒ b:s ⇒ a:u t ⇒ Unit ⇒ u s ~
	mapU t s (t⇒b) a id

Maybe = t:* ⇒ r:* → nothing:r → just:(a:t→r) → r
Nothing = t:* ⇒ r:* ⇒ nothing:r ⇒ just:(a:t→r) ⇒ r ~
	nothing
Just = t:* ⇒ a:t ⇒ r:* ⇒ nothing:r ⇒ just:(a:t→r) ⇒ r ~
	just a

fromMaybe = t:* ⇒ nothing:t ⇒ may:Maybe t ⇒ t ~
	may t nothing (a:t ⇒ a)

ordMaybe = t:* ⇒ ord:Ord t ⇒ Ord (Maybe t) ~
	x:Maybe t ⇒ y:Maybe t ⇒ Unit ⇒ Ordering ~
	x Ordering (y Ordering EQ (t ⇒ LT)) (x':t ⇒ y Ordering GT (y':t ⇒ ord x' y' id))
eqMaybe = t:* ⇒ eq:Eq t ⇒ Eq (Maybe t) ~
	x:Maybe t ⇒ y:Maybe t ⇒ Unit ⇒ Boolean ~
	x Boolean (y Boolean True (t ⇒ False)) (x':t ⇒ y Boolean False (y':t ⇒ eq x' y' id))
mapMaybe = Map Maybe ~
	t:* ⇒ s:* ⇒ f:(t→s) ⇒ ma:Maybe t ⇒ Unit ⇒ Maybe s ~
	ma (Maybe s) (Nothing s) (a:t ⇒ Just s (f a))

Pair = t:* ⇒ s:* ⇒ r:* → p:(t→s→r) → r
P = t:* ⇒ s:* ⇒ a:t ⇒ b:s ⇒ r:* ⇒ p:(t→s→r) ⇒ r ~
	p a b

fst = t:* ⇒ s:* ⇒ pair:Pair t s ⇒ t ~
	pair t (a:t ⇒ b:s ⇒ a)
snd = t:* ⇒ s:* ⇒ pair:Pair t s ⇒ s ~
	pair s (a:t ⇒ b:s ⇒ b)
swap = t:* ⇒ s:* ⇒ pair:Pair t s ⇒ Pair s t ~
	pair (Pair s t) (a:t ⇒ b:s ⇒ P s t b a)

eqPair = t:* ⇒ s: * ⇒ eqT:Eq t ⇒ eqS:Eq s ⇒ Eq (Pair t s) ~
	x:Pair t s ⇒ y:Pair t s ⇒ Unit ⇒ Boolean ~
	x Boolean (xa:t ⇒ xb:s ⇒ y Boolean (ya:t ⇒ yb:s ⇒ and (eqT xa ya id) (eqS xb yb id)))
ordPair = t:* ⇒ s: * ⇒ ordT:Ord t ⇒ ordS:Ord s ⇒ Ord (Pair t s) ~
	x:Pair t s ⇒ y:Pair t s ⇒ Unit ⇒ Ordering ~
	x Ordering (xa:t ⇒ xb:s ⇒ y Ordering (ya:t ⇒ yb:s ⇒ chainOrder (ordT xa ya id) (ordS xb yb id)))

Either = t:* ⇒ s:* ⇒ r:* → left:(a:t→r) → right:(b:s→r) → r
Left = t:* ⇒ s:* ⇒ a:t ⇒ r:* ⇒ left:(a:t→r) ⇒ right:(b:s→r) ⇒ r ~
	left a
Right = t:* ⇒ s:* ⇒ b:s ⇒ r:* ⇒ left:(a:t→r) ⇒ right:(b:s→r) ⇒ r ~
	right b

eqEither = t:* ⇒ s:* ⇒ eqT:Eq t ⇒ eqS:Eq s ⇒ Eq (Either t s) ~
	x:Either t s ⇒ y:Either t s ⇒ Unit ⇒ Boolean ~
	x Boolean (xa:t ⇒ y Boolean (ya:t ⇒ eqT xa ya id) (yb:s ⇒ False))
	          (xb:s ⇒ y Boolean (ya:t ⇒ False) (yb:s ⇒ eqS xb yb id))
mapLeft = s:* ⇒ Map (t:* ⇒ Either t s) ~
	t:* ⇒ r:* ⇒ f:(t→r) ⇒ a:Either t s ⇒ Unit ⇒ Either r s ~
	a (Either r s) (at:t ⇒ Left r s (f at)) (bs:s ⇒ Right r s bs)
mapRight = t:* ⇒ Map (Either t) ~
	s:* ⇒ r:* ⇒ f:(s→r) ⇒ a:Either t s ⇒ Unit ⇒ Either t r ~
	a (Either t r) (at:t ⇒ Left t r at) (bs:s ⇒ Right t r (f bs))

Nat = r:* → z:r → s:(p:r→r) → r
Z = r:* ⇒ z:r ⇒ s:(p:r→r) ⇒ r ~
	z
S = p:Nat ⇒ r:* ⇒ z:r ⇒ s:(p:r→r) ⇒ r ~
	s (p r z s)

precNat = x:Nat ⇒ Maybe Nat ~
	x (Maybe Nat) (Nothing Nat) (m:Maybe Nat ⇒ m (Maybe Nat) (Just Nat Z) (n:Nat ⇒ Just Nat (S n)))
precNatZ = x:Nat ⇒ Nat ~
	(precNat x) Nat Z (id Nat)
addNat = x:Nat ⇒ y:Nat ⇒ Nat ~
	x Nat y S
mulNat = x:Nat ⇒ y:Nat ⇒ Nat ~
	x Nat Z (addNat y)

Natural = r:* → zero:r → succ:(n:Natural→r) → r
Zero = r:* ⇒ zero:r ⇒ succ:(n:Natural→r) ⇒ zero
Succ = n:Natural ⇒ r:* ⇒ zero:r ⇒ succ:(n:Natural→r) ⇒ succ n

precNatural = n:Natural ⇒ Maybe Natural ~
	n (Maybe Natural) (Nothing Natural) (Just Natural)
precNaturalZ = x:Natural ⇒ Natural ~
	x Natural Zero (id Natural)
addNatural = n:Natural ⇒ m:Natural ⇒ Natural ~
	m Natural n (addNatural (Succ n))
mulNatural = n:Natural ⇒ m:Natural ⇒ Natural ~
	n Natural Zero (prec:Natural ⇒ addNatural m (mulNatural prec m))
evenNatural = n:Natural ⇒ Boolean ~
	n Boolean True (prec:Natural ⇒ not (evenNatural prec))

eqNatural = Eq Natural ~
	x:Natural ⇒ y:Natural ⇒ Unit ⇒ Boolean ~
	x Boolean (y Boolean True (Natural ⇒ False))
            (x':Natural ⇒ y Boolean False (y':Natural ⇒ eqNatural x' y' id))
ordNatural = Ord Natural ~
	x:Natural ⇒ y:Natural ⇒ Unit ⇒ Ordering ~
	x Ordering (y Ordering EQ (Natural ⇒ LT))
            (x':Natural ⇒ y Ordering GT (y':Natural ⇒ ordNatural x' y' id))

Crumb = Pair Boolean Boolean
crumb = x:Boolean ⇒ y:Boolean ⇒ P Boolean Boolean x y

Nibble = Pair Crumb Crumb
nibble = x:Crumb ⇒ y:Crumb ⇒ P Crumb Crumb x y

Byte = Pair Nibble Nibble
byte = x:Nibble ⇒ y:Nibble ⇒ P Nibble Nibble x y

Word = Pair Byte Byte
word = x:Byte ⇒ y:Byte ⇒ P Byte Byte x y

Quad = Pair Word Word
quad = x:Word ⇒ y:Word ⇒ P Word Word x y

addBoolean = x:Boolean ⇒ y:Boolean ⇒ z:Boolean ⇒ Pair Boolean Boolean ~
	x (Pair Boolean Boolean)
		(y (Pair Boolean Boolean)
			(z (Pair Boolean Boolean)
				(P Boolean Boolean False False)
				(P Boolean Boolean False True))
			(z (Pair Boolean Boolean)
				(P Boolean Boolean False True)
				(P Boolean Boolean True False)))
		(y (Pair Boolean Boolean)
			(z (Pair Boolean Boolean)
				(P Boolean Boolean False True)
				(P Boolean Boolean True False))
			(z (Pair Boolean Boolean)
				(P Boolean Boolean True False)
				(P Boolean Boolean True True)))

addBits = t:* ⇒ addT:(x:t→y:t→z:Boolean→Pair Boolean t) ⇒ x:Pair t t ⇒ y:Pair t t ⇒ z:Boolean ⇒ Pair Boolean (Pair t t) ~
	x (Pair Boolean (Pair t t)) (
		xx:t ⇒ xy:t ⇒ y (Pair Boolean (Pair t t)) (
			yx:t ⇒ yy:t ⇒ (addT xy yy False) (Pair Boolean (Pair t t)) (
				carry:Boolean ⇒ right:t ⇒ (addT xx yx carry) (Pair Boolean (Pair t t)) (
					carryOut:Boolean ⇒ left:t ⇒ P Boolean (Pair t t) carryOut (P t t left right)
				)
			)
		)
	)

addCrumb = addBits Boolean addBoolean

addNibble = addBits Crumb addCrumb

addByte = addBits Nibble addNibble

addWord = addBits Byte addByte

addQuad = addBits Word addWord

addModWord = x:Word ⇒ y:Word ⇒ Word ~
	snd Boolean Word (addWord x y False)

List = t:* ⇒ r:* → nil:r → cons:(x:t → xs:List t → r) → r
Nil = t:* ⇒ r:* ⇒ nil:r ⇒ cons:(x:t → xs:List t → r) ⇒ r ~
	nil
Cons = t:* ⇒ x:t ⇒ xs:List t ⇒ r:* ⇒ nil:r ⇒ cons:(x:t → xs:List t → r) ⇒ r ~
	cons x xs

concat = t:* ⇒ xs:List t ⇒ ys:List t ⇒ List t ~
	xs (List t) ys (x': t ⇒ xs':List t ⇒ Cons t x' (concat t xs' ys))
length = t:* ⇒ xs:List t ⇒ Natural ~
	xs Natural Zero (t ⇒ xs':List t ⇒ Succ (length t xs'))
index = t:* ⇒ xs:List t ⇒ n:Natural ⇒ Maybe t ~
	xs (Maybe t) (Nothing t) (x:t ⇒ xs':List t ⇒ n (Maybe t) (Just t x) (index t xs'))
indexWhere = t:* ⇒ pred:(x:t → Boolean) ⇒ xs:List t ⇒ Maybe Natural ~
	xs (Maybe Natural) (Nothing Natural) (x':t ⇒ xs':List t ⇒ (pred x') (Maybe Natural) (Just Natural Zero) (mapMaybe Natural Natural Succ (indexWhere t pred xs') id))
indexOf = t:* ⇒ eqT:Eq t ⇒ x:t ⇒ xs:List t ⇒ Maybe Natural ~
  indexWhere t (y:t ⇒ eqT x y id) xs

eqList = t:* ⇒ eqT:Eq t ⇒ Eq (List t) ~
  xs:List t ⇒ ys:List t ⇒ Unit ⇒ Boolean ~
	xs Boolean (ys Boolean True (t ⇒ List t ⇒ False))
	(x':t ⇒ xs':List t ⇒ ys Boolean False (y':t ⇒ ys':List t ⇒ and (eqT x' y' id) (eqList t eqT xs' ys' id)))
ordList = t:* ⇒ ordT:Ord t ⇒ Ord (List t) ~
	xs:List t ⇒ ys:List t ⇒ Unit ⇒ Ordering ~
	xs Ordering (ys Ordering EQ (t ⇒ List t ⇒ LT))
	            (x':t ⇒ xs':List t ⇒ ys Ordering GT (y':t ⇒ ys':List t ⇒ chainOrder (ordT x' y' id) (ordList t ordT xs' ys' id)))
mapList = Map List ~
	t:* ⇒ s:* ⇒ f:(a:t→s) ⇒ xs:List t ⇒ Unit ⇒ List s ~
	xs (List s) (Nil s) (x:t ⇒ xs':List t ⇒ Cons s (f x) (mapList t s f xs' id))
filterList = Filter List ~
	t:* ⇒ pred:(a:t→Boolean) ⇒ filter' = xs:List t ⇒ Unit ⇒ List t ~
  xs (List t) (Nil t)
	   (x':t ⇒ xs':List t ⇒ (ys':List t ⇒ (pred x') (List t) ys' (Cons t x' ys'))
                          (filter' xs' id))

String = List Quad
NilS = Nil Quad
ConsS = Cons Quad
concatS = concat Quad
charAt = index Quad

Expression = r:* →
	star:r →
	hole:r →
	ref:(n:Natural → r) →
	rec:(n:Natural → r) →
	hash:(hash:List Quad → name:String → r) →
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) →
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) →
	apply:(function:Expression → argument:Expression → name:String → r) →
	type:(outType:Expression → body:Expression → name:String → r) →
	r

Star = r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	star

Hole = r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	hole

Ref = n:Natural ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	ref n

Rec = n:Natural ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	rec n

Hash = value:List Quad ⇒
	name:String ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	hash value name

Forall = inType:Expression ⇒
	outType:Expression ⇒
	name:String ⇒
	boundName:String ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	forall inType outType name boundName

Lambda = inType:Expression ⇒
	body:Expression ⇒
	name:String ⇒
	boundName:String ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	lambda inType body name boundName

Apply = function:Expression ⇒
	argument:Expression ⇒
	name:String ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	apply function argument name

Type = outType:Expression ⇒
	body:Expression ⇒
	name:String ⇒
	r:* ⇒
	star:r ⇒
	hole:r ⇒
	ref:(n:Natural → r) ⇒
	rec:(n:Natural → r) ⇒
	hash:(hash:List Quad → name:String → r) ⇒
	forall:(inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(function:Expression → argument:Expression → name:String → r) ⇒
	type:(outType:Expression → body:Expression → name:String → r) ⇒
	type outType body name

Context = List Expression
NilContext = Nil Expression
ConsContext = Cons Expression

foldExpressionContextExpression = r:* ⇒
	star:(ctx:Context → r) ⇒
	hole:(ctx:Context → r) ⇒
	ref:(ctx:Context → n:Natural → r) ⇒
	rec:(ctx:Context → n:Natural → r) ⇒
	hash:(ctx:Context → hash:List Quad → name:String → r) ⇒
	forall:(ctx:Context → inType':r → outType':r → inType:Expression → outType:Expression → name:String → boundName:String → r) ⇒
	lambda:(ctx:Context → inType':r → body':r → inType:Expression → body:Expression → name:String → boundName:String → r) ⇒
	apply:(ctx:Context → function':r → argument':r → function:Expression → argument:Expression → name:String → r) ⇒
	type:(ctx:Context → outType':r → body':r → outType:Expression → body:Expression → name:String → r) ⇒
	outer = ctx:Context ⇒
	inner = expr:Expression ⇒
	r ~
	expr r (star ctx) (hole ctx) (ref ctx) (rec ctx) (hash ctx)
		(inType:Expression ⇒ outType:Expression ⇒ forall ctx (inner inType) (outer (ConsContext expr ctx) outType) inType outType)
		(inType:Expression ⇒ body:Expression ⇒ lambda ctx (inner inType) (outer (ConsContext expr ctx) body) inType body)
		(function:Expression ⇒ argument:Expression ⇒ apply ctx (inner function) (inner argument) function argument)
		(outType:Expression ⇒ body:Expression ⇒ type ctx (inner outType) (inner body) outType body)

foldExpressionContext = r:* ⇒
	star:(ctx:Context → r) ⇒
	hole:(ctx:Context → r) ⇒
	ref:(ctx:Context → n:Natural → r) ⇒
	rec:(ctx:Context → n:Natural → r) ⇒
	hash:(ctx:Context → hash:List Quad → name:String → r) ⇒
	forall:(ctx:Context → inType':r → outType':r → name:String → boundName:String → r) ⇒
	lambda:(ctx:Context → inType':r → body':r → name:String → boundName:String → r) ⇒
	apply:(ctx:Context → function':r → argument':r → name:String → r) ⇒
	type:(ctx:Context → outType':r → body':r → name:String → r) ⇒
	outer = ctx:Context ⇒
	inner = expr:Expression ⇒
	r ~
	expr r (star ctx) (hole ctx) (ref ctx) (rec ctx) (hash ctx)
		(inType:Expression ⇒ outType:Expression ⇒ forall ctx (inner inType) (outer (ConsContext expr ctx) outType))
		(inType:Expression ⇒ body:Expression ⇒ lambda ctx (inner inType) (outer (ConsContext expr ctx) body))
		(function:Expression ⇒ argument:Expression ⇒ apply ctx (inner function) (inner argument))
		(outType:Expression ⇒ body:Expression ⇒ type ctx (inner outType) (inner body))

shift = push:(Natural→Natural) ⇒ (Expression → Expression) ~
	foldExpressionContext Expression (Context⇒Star) (Context⇒Hole)
	(ctx:Context ⇒ n:Natural ⇒ Ref ((ordNatural (length Expression ctx) n id) Natural n n (push n)))
	(ctx:Context ⇒ n:Natural ⇒ Rec ((ordNatural (length Expression ctx) n id) Natural n n (push n)))
	(Context⇒Hash) (Context⇒Forall) (Context⇒Lambda) (Context⇒Apply) (Context⇒Type) NilContext

replace = ref:Expression ⇒ rec:Expression ⇒ expr:Expression ⇒ Expression ~
	shift precNaturalZ (foldExpressionContext Expression (Context⇒Star) (Context⇒Hole)
	(ctx:Context ⇒ n:Natural ⇒ (eqNatural (length Expression ctx) n id) Expression (shift (addNatural (Succ (length Expression ctx))) ref) (Ref n))
	(ctx:Context ⇒ n:Natural ⇒ (eqNatural (length Expression ctx) n id) Expression (shift (addNatural (Succ (length Expression ctx))) rec) (Rec n))
	(Context⇒Hash) (Context⇒Forall) (Context⇒Lambda) (Context⇒Apply) (Context⇒Type) NilContext expr)

applicate = hashExpr:(List Quad → Maybe Expression) ⇒ expr:Expression ⇒ Expression ~
  expr Expression Star Hole Ref Rec
	  (hash:List Quad ⇒ name:String ⇒ hashExpr hash Expression (Hash hash name) (id Expression))
    Forall Lambda
    (function:Expression ⇒ argument:Expression ⇒ name:String ⇒ (func':Expression ⇒ (repl:Expression ⇒ func' Expression
      repl repl (Natural ⇒ repl) (Natural ⇒ repl) (List Quad ⇒ String ⇒ repl) (Expression ⇒ Expression ⇒ String ⇒ String ⇒ repl)
			(Expression ⇒ body:Expression ⇒ String ⇒ String ⇒ replace argument func' body)
			(Expression ⇒ Expression ⇒ String ⇒ repl)
			(Expression ⇒ Expression ⇒ String ⇒ repl)
			) (Apply func' argument name)) (applicate hashExpr function))
		Type

reduce = expr:Expression ⇒ Expression ~
	foldExpressionContext Expression (Context⇒Star) (Context⇒Hole) (Context⇒Ref) (Context⇒Rec) (Context⇒Hash) (Context⇒Forall) (Context⇒Lambda)
	(Context ⇒ function:Expression ⇒ argument:Expression ⇒ name:String ⇒
	  (repl:Expression ⇒ function Expression repl repl (Natural⇒repl) (Natural⇒repl) (List Quad⇒String⇒repl) (Expression⇒Expression⇒String⇒String⇒repl)
		  (Expression ⇒ body:Expression ⇒ String ⇒ String ⇒ reduce (replace argument function body))
		  (Expression ⇒ Expression ⇒ String ⇒ repl) (Expression ⇒ Expression ⇒ String ⇒ repl)
		) (Apply function argument name)
	)
	(Context⇒Type) NilContext expr

